#!/usr/bin/env perl
# ABSTRACT: output HTML document as a flat XPath/content list
# PODNAME: xpathify
use strict;
use utf8;
use warnings qw(all);

use feature 'say';
use open qw(:std :utf8);

use Getopt::Long;
use HTML::Linear;
use IO::Interactive qw(is_interactive);
use Pod::Usage;
use Term::ANSIColor qw(:constants);

# VERSION

=head1 SYNOPSIS

    xpathify [options] HTML

=head1 DESCRIPTION

Represents a typical HTML document in a very verbose two-column mode.
The first column is a XPath which locates each element inside the HTML tree.
The second column is a respective content (if any).

    /html/head/title/text() test 1
    /html/body/h1/text()    test 2
    /html/body/p[1]/text()  Lorem ipsum dolor sit amet, consectetur adipiscing elit.

=head1 OPTIONS

=over 4

=item --help

This.

=item --encoding=name

Specify the HTML document encoding (C<latin1>, C<utf8>).
UTF-8 is assumed by default.

=item --[no]color

Enable syntax highlight for XPath.
By default, enabled automatically on interactive terminals.

=item --[no]shrink

Shrink the XPath to the minimal unique identifier.
For example:

    /html/body[@id='cpansearch']/form[@class='searchbox']/input[@name='query']

Could be shortened as:

    //input[@name='query']

The shrinking is enabled by default.

=item --[no]strict

Strict mode disables grouping by C<id>, C<class> or C<name> attributes.
The grouping is enabled by default.

=item --[no]weight

Print XPath weight on a second column.

=back

=cut

GetOptions(
    q(help)         => \my $help,
    q(color!)       => \my $color,
    q(encoding=s)   => \my $encoding,
    q(shrink!)      => \my $shrink,
    q(strict!)      => \my $strict,
    q(weight!)      => \my $weight,
) or pod2usage(q(-verbose) => 1);
pod2usage(q(-verbose) => 1)
    if $help or $#ARGV != 0;

$color //= is_interactive(*STDOUT);
$weight //= 0;

if ($color) {
    # ugly in the morning
    %HTML::Linear::Path::xpath_wrap = (
        array       => [BOLD . CYAN,            RESET],
        attribute   => [BOLD . BRIGHT_YELLOW,   RESET],
        equal       => [BOLD . YELLOW,          RESET],
        number      => [BOLD . BRIGHT_GREEN,    RESET],
        separator   => [BOLD . RED,             RESET],
        sigil       => [BOLD . MAGENTA,         RESET],
        tag         => [BOLD . BRIGHT_BLUE,     RESET],
        value       => [BOLD . BRIGHT_WHITE,    RESET],
    );
}

my $hl = HTML::Linear->new;

$hl->set_shrink
    if $shrink // 1;

$hl->set_strict
    if $strict // 0;

open(my $fh, '<:' . ($encoding ? "encoding($encoding)" : 'utf8' ), $ARGV[0])
    or die "Can't open $ARGV[0]: $!";
$hl->parse_file($fh)
    or die "Can't parse $ARGV[0]: $!";
close $fh;

for my $el ($hl->as_list) {
    my $hash = $el->as_hash;
    for (sort keys %{$hash}) {
        $hash->{$_} =~ s{(^\s+|\s+$)}{ON_RED . $1 . RESET}egsx
            if $color;
        my @line = $_;
        push @line, $el->weight if $weight;
        push @line, $hash->{$_};
        say join("\t", @line);
    }
}
